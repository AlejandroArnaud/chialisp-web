(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{72:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return l})),a.d(t,"metadata",(function(){return c})),a.d(t,"rightToc",(function(){return i})),a.d(t,"default",(function(){return O}));var n=a(2),r=a(6),b=(a(0),a(76)),l={id:"opcodes",title:"CLVM Reference Manual",sidebar_label:"2 - Opcodes"},c={unversionedId:"ref/opcodes",id:"ref/opcodes",isDocsHomePage:!1,title:"CLVM Reference Manual",description:"The clvm is a small, tightly defined VM that defines the semantics of CLVM programs run during Chia blockchain validation. It serves as a target language for higher level languages targeting CLVM, especially ChiaLisp.",source:"@site/docs/ref/opcodes.md",slug:"/ref/opcodes",permalink:"/docs/ref/opcodes",editUrl:"https://github.com/Chia-Network/chialisp-web/edit/master/docs/ref/opcodes.md",version:"current",sidebar_label:"2 - Opcodes",sidebar:"someSidebar",previous:{title:"CLVM Reference Manual",permalink:"/docs/ref/serialization"},next:{title:"ChiaLisp and CLVM FAQ",permalink:"/docs/faq"}},i=[{value:"Definitions",id:"definitions",children:[]},{value:"Types",id:"types",children:[{value:"Byte Array",id:"byte-array",children:[]},{value:"Unsigned Integer",id:"unsigned-integer",children:[]},{value:"Signed Integer",id:"signed-integer",children:[]},{value:"BLS Point",id:"bls-point",children:[]}]},{value:"Treeargs : Program Arguments, and Argument Lookup",id:"treeargs--program-arguments-and-argument-lookup",children:[]},{value:"Quoting",id:"quoting",children:[{value:"Compilation: Atom Syntax",id:"compilation-atom-syntax",children:[]}]},{value:"Errors",id:"errors",children:[]},{value:"The built-in opcodes",id:"the-built-in-opcodes",children:[]},{value:"List Operators",id:"list-operators",children:[]},{value:"Control Flow",id:"control-flow",children:[]},{value:"Constants",id:"constants",children:[]},{value:"Integer Operators",id:"integer-operators",children:[]},{value:"Bit Operations",id:"bit-operations",children:[]},{value:"Shifts",id:"shifts",children:[]},{value:"Strings",id:"strings",children:[]},{value:"Streaming Operators",id:"streaming-operators",children:[]},{value:"ECDSA operators",id:"ecdsa-operators",children:[]},{value:"Arithmetic and Bitwise Identities",id:"arithmetic-and-bitwise-identities",children:[]},{value:"Arithmetic",id:"arithmetic",children:[{value:"Behaviour of nil when used as an integer",id:"behaviour-of-nil-when-used-as-an-integer",children:[]},{value:"Behaviour of zero when used as a value that may be checked for nil",id:"behaviour-of-zero-when-used-as-a-value-that-may-be-checked-for-nil",children:[]}]},{value:"Detailed behaviour Notes",id:"detailed-behaviour-notes",children:[]},{value:"Argument Checking: Behaviour with fewer or more args than required",id:"argument-checking-behaviour-with-fewer-or-more-args-than-required",children:[{value:"Opcode List",id:"opcode-list",children:[]},{value:"Operator Results when called with zero arguments",id:"operator-results-when-called-with-zero-arguments",children:[]},{value:"Operator Results when called with fewer than minimum arguments",id:"operator-results-when-called-with-fewer-than-minimum-arguments",children:[]},{value:"Operator Results when called with too many arguments",id:"operator-results-when-called-with-too-many-arguments",children:[]},{value:"Conditions",id:"conditions",children:[]}]}],o={rightToc:i};function O(e){var t=e.components,a=Object(r.a)(e,["components"]);return Object(b.b)("wrapper",Object(n.a)({},o,a,{components:t,mdxType:"MDXLayout"}),Object(b.b)("p",null,"The clvm is a small, tightly defined VM that defines the semantics of CLVM programs run during Chia blockchain validation. It serves as a target language for higher level languages targeting CLVM, especially ChiaLisp."),Object(b.b)("h2",{id:"definitions"},"Definitions"),Object(b.b)("ul",null,Object(b.b)("li",{parentName:"ul"},Object(b.b)("strong",{parentName:"li"},"Atom")," - The underlying data type in the CLVM. Atoms are immutable byte arrays. Atoms are untyped and are used to encode all strings, integers, and keys. The only things in the CLVM which are not atoms are cons pairs."),Object(b.b)("li",{parentName:"ul"},Object(b.b)("strong",{parentName:"li"},"cons pair")," - An immutable ordered pair of references to other CLVM objects."),Object(b.b)("li",{parentName:"ul"},Object(b.b)("strong",{parentName:"li"},"nil")," - nil is the special value consisting of a string of length zero. The same value represents zero, null string, false, quote, empty list, and nil. Nil can be represented as ",Object(b.b)("inlineCode",{parentName:"li"},"()"),", ",Object(b.b)("inlineCode",{parentName:"li"},"0"),", ",Object(b.b)("inlineCode",{parentName:"li"},"''"),", or ",Object(b.b)("inlineCode",{parentName:"li"},"nil"),". The ",Object(b.b)("inlineCode",{parentName:"li"},"nil")," name refers to its use in the right cell of the last cons pair of a list to signal the end of the list."),Object(b.b)("li",{parentName:"ul"},Object(b.b)("strong",{parentName:"li"},"Value")," - We use value to mean an abstract value like ",Object(b.b)("inlineCode",{parentName:"li"},"1")," (an integer), ",Object(b.b)("inlineCode",{parentName:"li"},"0xCAFE")," (a byte string), ",Object(b.b)("inlineCode",{parentName:"li"},'"hello"')," (a string) or ",Object(b.b)("inlineCode",{parentName:"li"},'(sha256 (q "hello"))')," (a program). Values are represented by CLVM Objects."),Object(b.b)("li",{parentName:"ul"},Object(b.b)("strong",{parentName:"li"},"CLVM Object")," - An atom or cons pair and everything recursively pointed to by it. CLVM objects can't have contain circular references although they can contain redundant references into the same underlying object. Although redundant data structures can be created there's no way for the CLVM language to tell whether two objects are the same reference or merely contain the same data (there is no 'is' function) and there's no way to represent them in the current human readable serialization format."),Object(b.b)("li",{parentName:"ul"},Object(b.b)("strong",{parentName:"li"},"List")," - CLVM lists follow the lisp convention of being either a cons pair which contains the first element on the left and the rest of the list on the right or a nil indicating end of the list/empty list. While this is in many cases a higher layer semantic convention it does factor in to how programs are executed."),Object(b.b)("li",{parentName:"ul"},Object(b.b)("strong",{parentName:"li"},"Function")," - A function in the CLVM is either a built-in opcode or a user-defined program."),Object(b.b)("li",{parentName:"ul"},Object(b.b)("strong",{parentName:"li"},"Operator")," - An opcode/string specifying a built-in function to use."),Object(b.b)("li",{parentName:"ul"},Object(b.b)("strong",{parentName:"li"},"Program")," - A CLVM object which can be executed. When a program is executed it's passed a CLVM object as parameters and returns a CLVM object. On-chain programming involves a lot of usage of self-reference and what's called eval() in other languages, which is safe in this context due to the total lack of side effects."),Object(b.b)("li",{parentName:"ul"},Object(b.b)("strong",{parentName:"li"},"Opcodes")," - The strings used for function lookup by the CLVM. Unknown opcodes either error out or return nil depending on the context, likely error out for mempool checking or local testing and return nil when validating the blockchain for consensus."),Object(b.b)("li",{parentName:"ul"},Object(b.b)("strong",{parentName:"li"},"Tree")," - A binary tree can be formed from cons pairs and atoms by allowing the right and left cells of a cons pair to hold either an atom, or a cons pair. Atoms are the leaves of the tree."),Object(b.b)("li",{parentName:"ul"},"Function Parameter - All of the values in a list except the first. In the program ",Object(b.b)("inlineCode",{parentName:"li"},"(+ (q 1) (q 2))"),", the quoted atoms ",Object(b.b)("inlineCode",{parentName:"li"},"1")," and ",Object(b.b)("inlineCode",{parentName:"li"},"2")," are parameters to the operator ",Object(b.b)("inlineCode",{parentName:"li"},"+")),Object(b.b)("li",{parentName:"ul"},Object(b.b)("strong",{parentName:"li"},"Treearg")," - These are program arguments passed in from outside the program. They are referenced by integers."),Object(b.b)("li",{parentName:"ul"},Object(b.b)("strong",{parentName:"li"},"Argument"),' - Outside the context of the CLVM, the term "argument" can mean "program argument" (the "argv" of the C language, for example), or "function argument", among other things. Because of this potential confusion, we avoid using the term "argument" in this document. The context is especially important considering the way in which CLVM programs look up their program arguments.')),Object(b.b)("p",null,"A CLVM program must have an unambigious definition and meaning, so that Chia block validation and consensus is deterministic.\nPrograms are treated as Merkle trees, which are uniquely identified by the hash at their root. The program hash can be used to verify that two programs are identical."),Object(b.b)("h1",{id:"human-readable-serialization"},"Human readable serialization"),Object(b.b)("p",null,"Underlying CLVM objects contain atoms and cons pairs, but for convenience there's a human readable string format. In particular this format is what's passed in to brun. It isn't used anywhere in blockchain validation and has no impact on consensus. There are multiple ways of encoding the same CLVM object in the human readable serialization format, so going backwards to pretty print a CLVM object in this format requires guessing as to the best representation."),Object(b.b)("p",null,"Atoms in the human readable representation can be represented as directly quoted strings. They can also be expressed as integers which get converted to two's complement minimal encoding length. Built-in opcodes map directly to specific strings."),Object(b.b)("p",null,"Cons pairs can be represented using dot as an infix operator like so: ",Object(b.b)("inlineCode",{parentName:"p"},"(3 . 4)")," which corresponds to a cons box containing 3 and 4. A more common representation is for lists, which are done not using a dot and assume a nil terminator, for example ",Object(b.b)("inlineCode",{parentName:"p"},"(3 4 5)")," represents the same thing as ",Object(b.b)("inlineCode",{parentName:"p"},"(3 . (4 . (5 . nil)))"),". This can of course be used recursively as well. Note that ",Object(b.b)("inlineCode",{parentName:"p"},"0"),", ",Object(b.b)("inlineCode",{parentName:"p"},"nil"),", ",Object(b.b)("inlineCode",{parentName:"p"},"false"),", ",Object(b.b)("inlineCode",{parentName:"p"},"''"),", ",Object(b.b)("inlineCode",{parentName:"p"},"q"),", and ",Object(b.b)("inlineCode",{parentName:"p"},"()")," all get parsed to the same value."),Object(b.b)("h1",{id:"program-evaluation"},"Program Evaluation"),Object(b.b)("p",null,"The semantics of the language implemented by the CLVM is similar to Lisp. A program is represented as a tree, and the root of the tree is the outermost thing getting called, with later/inner function calls embedded recursively inside of it."),Object(b.b)("p",null,"Whenever a program is called it always has a context of a CLVM object which is the arguments passed in, referred to in the plural even though it's technically a single object."),Object(b.b)("p",null,"If the root of the program is an atom then an argument lookup is performed and returned. Please see ",Object(b.b)("a",Object(n.a)({parentName:"p"},{href:"#treeargs"}),"treeargs"),", below."),Object(b.b)("p",null,"If the the root of the program is a cons pair then a function call is made and the result of that function call is returned. The object on the left determines the function to call and the object on the right determines what arguments it gets passed."),Object(b.b)("p",null,"The left object is either an atom, in which case it's treated as an opcode, or a cons pair, in which case it's an implicit eval. The quote opcode is very special in that it's recognized by the interpreter and causes whatever's on the right to not be evaluated but instead returned verbatim. All other functions get passed the results of evaluating what's on the right first. When the interpreter evaluates the right value it does so using the lisp list convention: It either encounters a nil, in which case it returns nil, in which case it returns nil, or it encounters a cons pair, in which case it returns a cons pair containing the result of a recursive call to evalute using the current argument context to the thing on the left and the result of recursing evaluation to the thing on the right."),Object(b.b)("p",null,"If implicit evaluation is used then the value on the left is evaluated then it's called getting passed the value from evaluating what's on the right as context. This differs from recursive evaluation because it changes the argument context instead of that getting inherited. Note that if you want to run an argument passed in as a function you can't specify which arg at the outermost position using an atom because that will be treated as an opcode lookup but you can work around the limitation by using first on a list of length one which will treat an atom as an arg lookup during evaluation."),Object(b.b)("p",null,"A compiled CLVM program can be thought of as a binary tree."),Object(b.b)("p",null,'Here is an example of a function invocation ("function call"). ',Object(b.b)("inlineCode",{parentName:"p"},"(+ (q 1) (q 2))"),". The function is the opcode ",Object(b.b)("inlineCode",{parentName:"p"},"+"),", a function built in to the clvm runtime."),Object(b.b)("p",null,Object(b.b)("inlineCode",{parentName:"p"},"(+ (q 1) (q 2))")),Object(b.b)("pre",null,Object(b.b)("code",Object(n.a)({parentName:"pre"},{}),"      [ ]\n     /   \\\n    +     [ ]\n         /   \\\n      [q, 1]  [ ]\n             /   \\\n         [q, 2]  nil\n")),Object(b.b)("p",null,"After First Reduction"),Object(b.b)("p",null,Object(b.b)("inlineCode",{parentName:"p"},"(+ 1 2)")),Object(b.b)("pre",null,Object(b.b)("code",Object(n.a)({parentName:"pre"},{}),"      [ ]\n     /   \\\n    +     [ ]\n         /   \\\n        1     [ ]\n             /   \\\n            2    nil\n")),Object(b.b)("p",null,"After Second Reduction, and function application"),Object(b.b)("pre",null,Object(b.b)("code",Object(n.a)({parentName:"pre"},{}),"3\n")),Object(b.b)("p",null,"Program trees are evaluated by first evaluating the leaf nodes, then their parents, recursively.\nArguments to functions are always evaluated before the function is called.\nCLVM objects need not be evaluated in a specific order, but all child nodes must be evaluated before their parent."),Object(b.b)("p",null,"If the item is a quoted value, the value is returned."),Object(b.b)("p",null,"If the item is an atom, the atom is looked up as a Treearg."),Object(b.b)("p",null,"If the item to be evaluated is a list, all of the parameters are evaluated and then the evaluatted parameters are passed to the function"),Object(b.b)("p",null,"All arguments of a function are evaluated before being passed to that function."),Object(b.b)("h2",{id:"types"},"Types"),Object(b.b)("p",null,"The two types of CLVM Object are ",Object(b.b)("em",{parentName:"p"},"cons pair")," and ",Object(b.b)("em",{parentName:"p"},"atom"),". They can be distinguished by the ",Object(b.b)("strong",{parentName:"p"},"listp")," opcode. Atoms in the CLVM language do not carry other type information. However, similarly to the machine code instructions for a CPU, functions interpret atoms in specific predictible ways. Thus, each function imposes a type for each of its arguments."),Object(b.b)("p",null,"The value of an atom - its length, and the values of its bytes - are always well defined. Because atoms have no type information, the meaning of an atom is determined when a function is applied to it. For example, an atom may be parsed as an integer, concatenated to another atom, and then treated as a BLS point."),Object(b.b)("h3",{id:"byte-array"},"Byte Array"),Object(b.b)("p",null,"The atom is treated as an array of bytes, with a length. No specific semantics are assumed, except as specified in the instruction."),Object(b.b)("h3",{id:"unsigned-integer"},"Unsigned Integer"),Object(b.b)("p",null,"An unsigned integer of arbitrary length. If more bits are required to perform an operation with atoms of different length, the atom is virtually extended with zero bytes to the left."),Object(b.b)("h3",{id:"signed-integer"},"Signed Integer"),Object(b.b)("p",null,"The byte array behaves as a two's complement signed integer. The most significant bit denotes a negative number. The underlying representation matters, because the individual bytes are viewable through other operations."),Object(b.b)("p",null,"This type has the potential for multiple representations to be treated as the same value. For example, 0xFF and 0xFFFF both encode ",Object(b.b)("inlineCode",{parentName:"p"},"-1"),". Integer arithmetic operations that treat returned atoms as signed integers will return the minimal representation for negative numbers, eg. ",Object(b.b)("inlineCode",{parentName:"p"},"0xFF")," for ",Object(b.b)("inlineCode",{parentName:"p"},"-1")),Object(b.b)("p",null,"These integers are byte-aligned. For example, ",Object(b.b)("inlineCode",{parentName:"p"},"0xFFF")," is interpreted as ",Object(b.b)("inlineCode",{parentName:"p"},"4095"),"."),Object(b.b)("h3",{id:"bls-point"},"BLS Point"),Object(b.b)("p",null,"This type represents a point on an elliptic curve over finite field described ",Object(b.b)("a",Object(n.a)({parentName:"p"},{href:"https://electriccoin.co/blog/new-snark-curve/"}),"here"),"."),Object(b.b)("h2",{id:"treeargs--program-arguments-and-argument-lookup"},"Treeargs : Program Arguments, and Argument Lookup"),Object(b.b)("p",null,"For a program running on a deterministic machine to have different behaviours, it must be able to take take have different starting states. The starting state for a CLVM program is the program argument list - the treearg."),Object(b.b)("p",null,"When an unquoted integer is evaluated, it is replaced with the corresponding value/CLVM Object from the program Treearg."),Object(b.b)("p",null,"As an improvement over walking the argument tree via calls to ",Object(b.b)("strong",{parentName:"p"},"first")," and ",Object(b.b)("strong",{parentName:"p"},"rest"),", arguments are indexed from the argument list by their argument number. This number is derived by translating the path of left and right nodes through the argument tree into a series of ones and zeros corresponding to the path to the CLVM Object in the argument tree, starting at the least significant bit. The number of the root of the argument tree is ",Object(b.b)("inlineCode",{parentName:"p"},"1")," (",Object(b.b)("inlineCode",{parentName:"p"},"0")," will also evaluate to the root of the argtree)."),Object(b.b)("p",null,"We treat an s-expression as a binary tree, where leaf nodes are atoms, and cons pairs\nare nodes with two children. We then number the paths as follows:"),Object(b.b)("pre",null,Object(b.b)("code",Object(n.a)({parentName:"pre"},{}),"              1\n             / \\\n            /   \\\n           /     \\\n          /       \\\n         /         \\\n        /           \\\n       2             3\n      / \\           / \\\n     /   \\         /   \\\n    4      6      5     7\n   / \\    / \\    / \\   / \\\n  8   12 10  14 9  13 11  15\n\netc.\n")),Object(b.b)("p",null,"This quirky numbering makes the implementation simple.\nIt starts at the argument passed in, and if the index is 1 it returns args directly otherwise\nit uses the lest significant bit to decide whether to recurse left or right and and right\nshifts the index one bit."),Object(b.b)("p",null,"See the implementation ",Object(b.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/Chia-Network/clvm_tools/blob/master/clvm_tools/NodePath.py"}),"here")),Object(b.b)("h2",{id:"quoting"},"Quoting"),Object(b.b)("p",null,"In most programming languages, evaluating a literal returns the evaluated value itself.\nIn CLVM, the meaning of an atom at evaluation time is a reference to a value in the argument tree."),Object(b.b)("p",null,"Therefore, when you intend to write:"),Object(b.b)("p",null,Object(b.b)("inlineCode",{parentName:"p"},"(+ 1 2)")," => ",Object(b.b)("inlineCode",{parentName:"p"},"3")),Object(b.b)("p",null,"You must instead write:\n",Object(b.b)("inlineCode",{parentName:"p"},"(+ (q 1) (q 2))")," => ",Object(b.b)("inlineCode",{parentName:"p"},"3")),Object(b.b)("p",null,"nil is self-quoting."),Object(b.b)("h3",{id:"compilation-atom-syntax"},"Compilation: Atom Syntax"),Object(b.b)("p",null,"Although there is only one underlying representation of an atom, different syntaxes are recognized during compile time, and those atom syntaxes are interpreted differently during the translation from program text to CLVM Objects."),Object(b.b)("p",null,"Nil, decimal zero and the empty string all evaluate to the same atom."),Object(b.b)("p",null,Object(b.b)("inlineCode",{parentName:"p"},"(q ())")," => ",Object(b.b)("inlineCode",{parentName:"p"},"()")),Object(b.b)("p",null,Object(b.b)("inlineCode",{parentName:"p"},"(q 0)")," => ",Object(b.b)("inlineCode",{parentName:"p"},"()")),Object(b.b)("p",null,Object(b.b)("inlineCode",{parentName:"p"},'(q "")')," => ",Object(b.b)("inlineCode",{parentName:"p"},"()")),Object(b.b)("p",null,"which is not the same as a sigle zero byte."),Object(b.b)("p",null,Object(b.b)("inlineCode",{parentName:"p"},"(q 0x0)")," => ",Object(b.b)("inlineCode",{parentName:"p"},"0x00")),Object(b.b)("h4",{id:"equivalence-of-strings-symbols-hex-strings-and-numbers"},"Equivalence of Strings, symbols, hex strings, and numbers"),Object(b.b)("p",null,Object(b.b)("inlineCode",{parentName:"p"},'"A"')," is the same atom as ",Object(b.b)("inlineCode",{parentName:"p"},"A")),Object(b.b)("pre",null,Object(b.b)("code",Object(n.a)({parentName:"pre"},{}),'(q "A") => 65\n(q A) => 65\n(q 65) => 65\n(q 0x41) => 65\n\n')),Object(b.b)("p",null,"However, the same is not true for Built-ins.\n",Object(b.b)("inlineCode",{parentName:"p"},'"q"')," is not the same as ",Object(b.b)("inlineCode",{parentName:"p"},"q")),Object(b.b)("pre",null,Object(b.b)("code",Object(n.a)({parentName:"pre"},{}),'(q q) => 1\n(q "q") => 113\n')),Object(b.b)("h2",{id:"errors"},"Errors"),Object(b.b)("p",null,"While running a clvm program, checks are made to ensure the CLVM does not enter an undefined state. When a program violates one of these runtime checks, it is said to have caused an error."),Object(b.b)("p",null,"TODO We need the full list of errors."),Object(b.b)("ul",null,Object(b.b)("li",{parentName:"ul"},"First element in an evaluated list is not a valid function. Example: ",Object(b.b)("inlineCode",{parentName:"li"},'("hello" (q 1))')," => ",Object(b.b)("inlineCode",{parentName:"li"},'FAIL: unimplemented operator "hello"')),Object(b.b)("li",{parentName:"ul"},"Wrong number of arguments. Example: ",Object(b.b)("inlineCode",{parentName:"li"},"(lognot (q 1) (q 2))")," => ",Object(b.b)("inlineCode",{parentName:"li"},"FAIL: lognot requires 1 arg")),Object(b.b)("li",{parentName:"ul"},"Program evaluation exceeds max cost see ",Object(b.b)("a",Object(n.a)({parentName:"li"},{href:"/docs/ref/opcodes#costs"}),"Costs")),Object(b.b)("li",{parentName:"ul"},"Too many allocations have been performed")),Object(b.b)("p",null,"An error will cause the program to abort."),Object(b.b)("h1",{id:"operator-summary"},"Operator Summary"),Object(b.b)("h2",{id:"the-built-in-opcodes"},"The built-in opcodes"),Object(b.b)("p",null,"Opcodes are functions built in to the CLVM. They are available to any running program."),Object(b.b)("h2",{id:"list-operators"},"List Operators"),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"c")," ",Object(b.b)("em",{parentName:"p"},"cons")," ",Object(b.b)("inlineCode",{parentName:"p"},"(c A B)")," takes exactly two operands and returns a cons pair with the two objects in it (A in the left, B in the right)"),Object(b.b)("p",null,"Example: ",Object(b.b)("inlineCode",{parentName:"p"},"'(c (q \"A\") (q ()))'")," => ",Object(b.b)("inlineCode",{parentName:"p"},"(65)")),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"f")," ",Object(b.b)("em",{parentName:"p"},"first")," ",Object(b.b)("inlineCode",{parentName:"p"},"(f X)")," takes exactly one operand which must be a cons pair, and returns the left half"),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"r")," ",Object(b.b)("em",{parentName:"p"},"rest")," ",Object(b.b)("inlineCode",{parentName:"p"},"(r X)")," takes exactly one operand which must be a cons pair, and returns the right half"),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"l")," ",Object(b.b)("em",{parentName:"p"},"listp")," ",Object(b.b)("inlineCode",{parentName:"p"},"(l X)")," takes exactly one operand and returns ",Object(b.b)("inlineCode",{parentName:"p"},"()")," if it is an atom or ",Object(b.b)("inlineCode",{parentName:"p"},"1")," if it is a cons pair. In contrast to most other lisps, nil is not a list in CLVM."),Object(b.b)("h2",{id:"control-flow"},"Control Flow"),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"i")," ",Object(b.b)("em",{parentName:"p"},"if")," ",Object(b.b)("inlineCode",{parentName:"p"},"(i A B C)")," takes exactly three operands ",Object(b.b)("inlineCode",{parentName:"p"},"A"),", ",Object(b.b)("inlineCode",{parentName:"p"},"B"),", ",Object(b.b)("inlineCode",{parentName:"p"},"C"),". If ",Object(b.b)("inlineCode",{parentName:"p"},"A")," is ",Object(b.b)("inlineCode",{parentName:"p"},"()"),", return ",Object(b.b)("inlineCode",{parentName:"p"},"C"),". Otherwise, return ",Object(b.b)("inlineCode",{parentName:"p"},"B"),". Both B and C are evaluated before ",Object(b.b)("em",{parentName:"p"},"if")," is evaluated."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"x")," ",Object(b.b)("em",{parentName:"p"},"raise")," ",Object(b.b)("inlineCode",{parentName:"p"},"(x X Y ...)")," takes an arbitrary number of arguments (even zero). Immediately fail, with the argument list passed up into the (python) exception. No other CLVM instructions are run after this instruction is evaluated."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"=")," ",Object(b.b)("em",{parentName:"p"},"equal")," ",Object(b.b)("inlineCode",{parentName:"p"},"(= A B)")," returns 1 if ",Object(b.b)("inlineCode",{parentName:"p"},"A")," and ",Object(b.b)("inlineCode",{parentName:"p"},"B")," are both atoms and both equal. Otherwise ",Object(b.b)("inlineCode",{parentName:"p"},"()"),". Do not use this to test if two programs are identical. Use ",Object(b.b)("strong",{parentName:"p"},"sha256tree"),". Nil tests equal to zero, but nil is not equal to a single zero byte."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},">")," ",Object(b.b)("em",{parentName:"p"},"greater than")," ",Object(b.b)("inlineCode",{parentName:"p"},"(> A B)")," returns 1 if ",Object(b.b)("inlineCode",{parentName:"p"},"A")," and ",Object(b.b)("inlineCode",{parentName:"p"},"B")," are both atoms and A is greater than B, interpreting both as two's complement signed integers. Otherwise ",Object(b.b)("inlineCode",{parentName:"p"},"()"),". ",Object(b.b)("inlineCode",{parentName:"p"},"(> A B)")," means ",Object(b.b)("inlineCode",{parentName:"p"},"A > B")," in infix syntax."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},">s")," ",Object(b.b)("em",{parentName:"p"},"greater than bytes")," ",Object(b.b)("inlineCode",{parentName:"p"},"(>s A B)")," returns 1 if ",Object(b.b)("inlineCode",{parentName:"p"},"A")," and ",Object(b.b)("inlineCode",{parentName:"p"},"B")," are both atoms and A is greater than B, interpreting both as an array of unsigned bytes. Otherwise ",Object(b.b)("inlineCode",{parentName:"p"},"()"),". Compare to strcmp.\n",Object(b.b)("inlineCode",{parentName:"p"},'(>s "a" "b")')," => ",Object(b.b)("inlineCode",{parentName:"p"},"()")),Object(b.b)("h2",{id:"constants"},"Constants"),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"q")," ",Object(b.b)("em",{parentName:"p"},"quote")," ",Object(b.b)("inlineCode",{parentName:"p"},"(q X)")," takes exactly one operand which is ",Object(b.b)("em",{parentName:"p"},"not")," evaluated and returns it\nExample: ",Object(b.b)("inlineCode",{parentName:"p"},'(q "A")')," => ",Object(b.b)("inlineCode",{parentName:"p"},"(65)")),Object(b.b)("h2",{id:"integer-operators"},"Integer Operators"),Object(b.b)("p",null,"The arithmetic operators ",Object(b.b)("inlineCode",{parentName:"p"},"+"),", ",Object(b.b)("inlineCode",{parentName:"p"},"-"),", ",Object(b.b)("inlineCode",{parentName:"p"},"*")," and ",Object(b.b)("inlineCode",{parentName:"p"},"divmod")," treat their arguments as signed integers."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},Object(b.b)("inlineCode",{parentName:"strong"},"+"))," ",Object(b.b)("inlineCode",{parentName:"p"},"(+ a0 a1 ...)")," takes any number of integer operands and sums them. If given no arguments, zero is returned."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},Object(b.b)("inlineCode",{parentName:"strong"},"-"))," ",Object(b.b)("inlineCode",{parentName:"p"},"(- a0 a1 ...)")," takes one or more integer operands and adds a0 to the negative of the rest. Giving zero arguments returns 0."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},Object(b.b)("inlineCode",{parentName:"strong"},"*"))," ",Object(b.b)("inlineCode",{parentName:"p"},"(* a0 a1 ...)")," takes any number of integer operands and returns the product."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"divmod")," ",Object(b.b)("inlineCode",{parentName:"p"},"(divmod A B)")," takes two integers and returns a list containing the floored quotient and the remainder"),Object(b.b)("h2",{id:"bit-operations"},"Bit Operations"),Object(b.b)("p",null,"logand, logior and logxor operate on any number of arguments\nIf any argument is nil, they return nil. Fail if either A or B is not an atom.\nThe shorter atom is considered to be extended with zero bytes until equal in length to the longer atom."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"logand")," ",Object(b.b)("inlineCode",{parentName:"p"},"(logand A B ...)")," bitwise ",Object(b.b)("strong",{parentName:"p"},"AND")," of one or more atoms. Given zero arguments, returns ",Object(b.b)("inlineCode",{parentName:"p"},"-1"),"."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"logior")," ",Object(b.b)("inlineCode",{parentName:"p"},"(logior A B ...)")," bitwise logical ",Object(b.b)("strong",{parentName:"p"},"OR")," of one or more atoms. Given zero arguments, returns zero."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"logxor")," ",Object(b.b)("inlineCode",{parentName:"p"},"(logxor A B)")," bitwise ",Object(b.b)("strong",{parentName:"p"},"XOR")," of any number of atoms. Given zero arguments, returns zero."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"lognot")," ",Object(b.b)("inlineCode",{parentName:"p"},"(lognot A)")," bitwise ",Object(b.b)("strong",{parentName:"p"},"NOT")," of A. All bits are inverted."),Object(b.b)("h2",{id:"shifts"},"Shifts"),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"ash")," ",Object(b.b)("inlineCode",{parentName:"p"},"(ash A B)")," if B is positive, return Arithmetic shift A << B. Else returns A >> |B|. ",Object(b.b)("em",{parentName:"p"},"ash")," sign extends."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"lsh")," ",Object(b.b)("inlineCode",{parentName:"p"},"(lsh A B)")," if B is positive, Logical shift A by B bits left. Else Logical shift A >> |B|. Zeros are inserted into the vacated bits."),Object(b.b)("h2",{id:"strings"},"Strings"),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"substr")," ",Object(b.b)("inlineCode",{parentName:"p"},"(substr S I1 I2)")," return an atom containing bytes indexed from I1 to I2. The MSB of S is byte zero. If I1 == I2, returns nil."),Object(b.b)("pre",null,Object(b.b)("code",Object(n.a)({parentName:"pre"},{}),'(substr (q "clvm") (q 0) (q 4)) => clvm\n(substr (q "clvm") (q 2) (q 4)) => vm\n(substr (q "clvm") (q 4) (q 4)) => ()\n\n(substr (q "clvm") (q 4) (q 5)) => FAIL\n(substr (q "clvm") (q 1) (q 0)) => FAIL\n(substr (q "clvm") (q -1) (q 4)) => FAIL\n')),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"strlen")," ",Object(b.b)("inlineCode",{parentName:"p"},"(strlen S)")," return the number of bytes in S."),Object(b.b)("pre",null,Object(b.b)("code",Object(n.a)({parentName:"pre"},{}),'(strlen (q "clvm")) => 4\n(strlen (q "0x0")) => 1\n(strlen (q "")) => ()\n(strlen (q 0)) => ()\n(strlen (q ())) => ()\n(strlen ()) => ()\n')),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"concat")," ",Object(b.b)("inlineCode",{parentName:"p"},"(concat A ...)")," return the concatenation of any number of atoms."),Object(b.b)("p",null,"Example: ",Object(b.b)("inlineCode",{parentName:"p"},'(concat (q "Hello") (q " ") (q "world"))')," => ",Object(b.b)("inlineCode",{parentName:"p"},'"Hello world"')),Object(b.b)("h2",{id:"streaming-operators"},"Streaming Operators"),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"sha256"),"\n",Object(b.b)("inlineCode",{parentName:"p"},"(sha256 A ...)")," returns the sha256 hash (as a 32-byte blob) of the bytes of its parameters."),Object(b.b)("pre",null,Object(b.b)("code",Object(n.a)({parentName:"pre"},{}),'(sha256 (q "clvm")) => 0xcf3eafb281c0e0e49e19c18b06939a6f7f128595289b08f60c68cef7c0e00b81\n(sha256 (q "cl") (q "vm")) => 0xcf3eafb281c0e0e49e19c18b06939a6f7f128595289b08f60c68cef7c0e00b81\n')),Object(b.b)("h2",{id:"ecdsa-operators"},"ECDSA operators"),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"point_add"),"\n",Object(b.b)("inlineCode",{parentName:"p"},"(point_add a0 a1 ...)")," takes an arbitrary number of bls12_381 points and adds them"),Object(b.b)("p",null,"Example: ",Object(b.b)("inlineCode",{parentName:"p"},"(point_add (pubkey_for_exp (q 1)) (pubkey_for_exp (q 2)))")," => ",Object(b.b)("inlineCode",{parentName:"p"},"0x89ece308f9d1f0131765212deca99697b112d61f9be9a5f1f3780a51335b3ff981747a0b2ca2179b96d2c0c9024e5224")),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"pubkey_for_exp"),"\n",Object(b.b)("inlineCode",{parentName:"p"},"(pubkey_for_exp A)")," turns the integer A into a bls12_381 point"),Object(b.b)("p",null,Object(b.b)("inlineCode",{parentName:"p"},"(pubkey_for_exp (q 1))")," => ",Object(b.b)("inlineCode",{parentName:"p"},"0x97f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb")),Object(b.b)("h2",{id:"arithmetic-and-bitwise-identities"},"Arithmetic and Bitwise Identities"),Object(b.b)("p",null,"Some operators have a special value that is returned when they are called with zero arguments. This value is the identity of that function."),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Operator"),Object(b.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Identity"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(b.b)("inlineCode",{parentName:"td"},"+")),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(b.b)("inlineCode",{parentName:"td"},"*")),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"1")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"AND"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"all 1's")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"OR"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"all zeros")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"XOR"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"all zeros")))),Object(b.b)("h2",{id:"arithmetic"},"Arithmetic"),Object(b.b)("h3",{id:"behaviour-of-nil-when-used-as-an-integer"},"Behaviour of nil when used as an integer"),Object(b.b)("p",null,"When used in an integer context, nil behaves as zero."),Object(b.b)("h3",{id:"behaviour-of-zero-when-used-as-a-value-that-may-be-checked-for-nil"},"Behaviour of zero when used as a value that may be checked for nil"),Object(b.b)("p",null,"When used as a parameter that may be checked for nil, zero is interpreted as nil."),Object(b.b)("h1",{id:"operator-specification"},"Operator specification"),Object(b.b)("p",null,"All documentation in the Opcode section omits the necessary quote operator around each literal."),Object(b.b)("p",null,"If a precondition is not met, it is an error. Checking argument count is covered later in the document."),Object(b.b)("p",null,"Conventions used in the Operator Table"),Object(b.b)("ul",null,Object(b.b)("li",{parentName:"ul"},"N: the number of arguments. For ",Object(b.b)("inlineCode",{parentName:"li"},"(+ (q 1) (q 2))"),", N = ",Object(b.b)("inlineCode",{parentName:"li"},"2")),Object(b.b)("li",{parentName:"ul"},"strlen(atom): number of bytes in an atom."),Object(b.b)("li",{parentName:"ul"},"max_arg_strlen: the length of the longest arg atom, in bytes"),Object(b.b)("li",{parentName:"ul"},"result: the return value of the function")),Object(b.b)("p",null,"All opcodes below accept arguments as a ",Object(b.b)("a",Object(n.a)({parentName:"p"},{href:"opcodes#definitions"}),"flat list"),"."),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"keyword"),Object(b.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"opcode"),Object(b.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"impl"),Object(b.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"funcall"),Object(b.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"args"),Object(b.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"return"),Object(b.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"preconditions"),Object(b.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"cost"),Object(b.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Allocations"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"i"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x04"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_if"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(i C A B)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"3"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"if C==nil then B else A"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null})),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"10"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"None")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"c"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x05"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_cons"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(c A B)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"2"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"cons pair containing ","[A,B]"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null})),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"10"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"1 cons")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"f"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x06"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_first"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(f L)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"1"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"left cell of cons pair L"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"L is not atom"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"10"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"None")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"r"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x07"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_rest"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(r L)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"1"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"right cell of cons pair L"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"L is not atom"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"10"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"None")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"l"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x08"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_listp"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(l A)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"1"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"return 1 if A is a cons pair, else nil"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null})),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"20"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"None")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"x"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x09"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_raise"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(x ...)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),">=0"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"stop program execution"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null})),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"N/A"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"None")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"="),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x0a"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_eq"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(= A B)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"2"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"if A == B then 1 else nil"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"A and B are atoms"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"len(A) + len(B)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"None")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"sha256"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x0b"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_sha256"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(sha256 ...)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),">=0"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"return sha256 of ",Object(b.b)("em",{parentName:"td"},"concat")," of args"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"All args are atoms"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"2 * len(args)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Atom(32)")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"+"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x0c"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_add"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(+ A B ...)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),">=0"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"A + B + ..."),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"All args are atoms"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"strlen(concat A B ...)) * 10"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Atom(max(map(strlen, args)) + 1)")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"-"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x0d"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_subtract"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(- A B ...)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),">=0"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"A + B + ..."),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"All args are atoms"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"strlen(concat A B ...)) * 10"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Atom(max(map(strlen, args)))")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(b.b)("inlineCode",{parentName:"td"},"*")),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x0e"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_multiply"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(* A B ...)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),">=0"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"A ",Object(b.b)("em",{parentName:"td"}," B ")," ..."),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"All args are atoms"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"strlen(A) ",Object(b.b)("em",{parentName:"td"}," strlen(B) ")," ... * 10"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}))),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"divmod"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x0f"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_divmod"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(divmod A B)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"2"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"((div A B) . (mod A B))"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"A and B are atoms"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"strlen(concat A B ...)) * 10"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Atom(len(A) ",Object(b.b)("em",{parentName:"td"}," len(B) ")," ...)")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"substr"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x10"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_substr"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(substr S start end)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"3"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"new atom with bytes from"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(b.b)("ul",null,Object(b.b)("li",null,"S is atom"),Object(b.b)("li",null,"start <= end"),Object(b.b)("li",null,"start>=0"),Object(b.b)("li",null,"end>=0"),Object(b.b)("li",null,"end<=len(S)"))),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"1"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Atom(len(S))")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"strlen"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x11"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_strlen"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(strlen S)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"1"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"length of atom S"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"S is atom"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"len(S)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"None")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"point_add"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x12"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_point_add"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(point_add P1 P2 ...)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),">=0"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Sum any number, N, of G1 Elements"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"P","[n]"," are 48 bytes in length"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"N * 32"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Atom(96)")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"pubkey_for_exp"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x13"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_pubkey_for_exp"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(pubkey_for_exp E)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"1"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Get pubkey for E"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"E is an atom"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"900"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Atom(96)")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"concat"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x14"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_concat"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(concat A B ...)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),">=0"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Concatenate args"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"2 * (len(A) + len(B) + ...)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Atom(map(sum, arg_lens))"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}))),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"sha256tree"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x15"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_sha256tree"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(sha256tree L)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"1"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Recursive sha256 of all leaf nodes of L"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null})),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(len_of_all_atoms",Object(b.b)("em",{parentName:"td"},"10) + (Number of CLVM Objects ")," 10) TODO: Check"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Atom(32)")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(b.b)("inlineCode",{parentName:"td"},">")),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x16"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_gr"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(> A B)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"2"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"if A > B then 1 else nil. Int conversion via Python's ",Object(b.b)("a",Object(n.a)({parentName:"td"},{href:"https://docs.python.org/3/library/stdtypes.html#int.from_bytes"}),"int.from_bytes")),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"A and B are atoms"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(b.b)("p",{style:{color:"red"}},"10 * max(A,B)")),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"None")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(b.b)("inlineCode",{parentName:"td"},">s")),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x17"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_gr_bytes"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(>s A B)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"2"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Unsigned greater than"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"A and B are atoms"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(b.b)("p",{style:{color:"red"}},"max(A,B)")),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"None")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"logand"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x18"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_logand"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(logand A B ...)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),">=0"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Bitwise AND of args"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"All args are atoms"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"max_arg_strlen * 2"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Atom(max(arg_lens))")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"logior"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x19"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_logior"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(logior A B ...)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),">=0"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Bitwise OR of args"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"All args are atoms"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"max_arg_strlen * 2"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Atom(max(arg_lens))")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"logxor"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x1a"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_logxor"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(logxor A B)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"2"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Bitwise XOR of args. The bit is 1 if that bit is 1 in an odd number of the arguments"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"All args are atoms"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"max_arg_strlen * 2"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Atom(max(arg_lens))")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"lognot"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x1b"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_lognot"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(lognot A)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"1"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Flip every bit in A"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"A is an atom"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"strlen(A)*2"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Atom(len(A))")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"ash"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x1c"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_ash"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(ash A B)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"2"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Arithmetic shift. if B >= 0, A << B. Else A >> abs(B). Shift in 1's if right shifting a negative number"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"A and B are atoms"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"2 * (strlen(A) + strlen(result))"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Atom(len(result))")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"lsh"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x1d"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_lsh"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(lsh A B)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"2"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Unsigned shift. if B >= 0, A << B. Else A >> abs(B). Shift in 0's in all cases"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"A and B are atoms"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"2 * (strlen(A) + strlen(result))"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Atom(len(result))")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"softfork"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x1e"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_softfork"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(softfork COST)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"1"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null})),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"COST>=1"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null})),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"None")))),Object(b.b)("h2",{id:"detailed-behaviour-notes"},"Detailed behaviour Notes"),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"ash")),Object(b.b)("pre",null,Object(b.b)("code",Object(n.a)({parentName:"pre"},{}),"(ash (q 1) (q 1)) => 2\n(ash (q 1) (q -1)) => 0\n")),Object(b.b)("p",null,"Consecutive right shifts of negative numbers will result in a terminal value of -1."),Object(b.b)("pre",null,Object(b.b)("code",Object(n.a)({parentName:"pre"},{}),"(ash -7 -1) ; -7 = . . . 111111111111111111111111111001\n(ash -4 -1) ; -4 = . . . 111111111111111111111111111100\n(ash -2 -1) ; -2 = . . . 111111111111111111111111111110\n(ash -1 -1) ; -1 = . . . 111111111111111111111111111111\n")),Object(b.b)("p",null,"That is, a right shift (negative shift count) of ",Object(b.b)("inlineCode",{parentName:"p"},"-1")," by any amount is ",Object(b.b)("inlineCode",{parentName:"p"},"-1"),":"),Object(b.b)("pre",null,Object(b.b)("code",Object(n.a)({parentName:"pre"},{}),"(ash (q -1) (q -99)) => -1\n")),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"lsh")),Object(b.b)("p",null,"lsh behaviour from the ",Object(b.b)("a",Object(n.a)({parentName:"p"},{href:"https://www.gnu.org/software/emacs/manual/pdf/elisp.pdf"}),"elisp manual"),":"),Object(b.b)("pre",null,Object(b.b)("code",Object(n.a)({parentName:"pre"},{}),"(ash -7 -1) ; -7 = . . . 111111111111111111111111111001\n          \u21d2 -4 ; = . . . 111111111111111111111111111100\n\n(lsh -7 -1)\n   \u21d2 536870908 ; = . . . 011111111111111111111111111100\n\n(ash -5 -2) ; -5 = . . . 111111111111111111111111111011\n          \u21d2 -2 ; = . . . 111111111111111111111111111110\n\n(lsh -5 -2)\n   \u21d2 268435454 ; = . . . 001111111111111111111111111110\n")),Object(b.b)("p",null,"A left shift of an atom with the high bit set will extend the atom left, and result in an allocation"),Object(b.b)("pre",null,Object(b.b)("code",Object(n.a)({parentName:"pre"},{}),"(lsh (q -1) (q 1)) => 0x01FE\n(strlen (lsh (q -1) (q 1))) => 2\n\n\n")),Object(b.b)("p",null,"A left arithmetic shift will only extend the atom length when more bits are needed"),Object(b.b)("pre",null,Object(b.b)("code",Object(n.a)({parentName:"pre"},{}),"(strlen (ash (q -1) (q 7))) => 1\n(strlen (ash (q -1) (q 8))) = >2\n")),Object(b.b)("pre",null,Object(b.b)("code",Object(n.a)({parentName:"pre"},{}),"(strlen (ash (q 255) (q 1)))\n(strlen (ash (q 128) (q 1)))\n(strlen (ash (q 127) (q 1)))\n\n(strlen (lsh (q 255) (q 1)))\n(strlen (lsh (q 128) (q 1)))\n(strlen (lsh (q 127) (q 1)))\n\n")),Object(b.b)("h1",{id:"costs"},"Costs"),Object(b.b)("p",null,"The minimum program cost is 40. After each opcode is run, its cost is added to the total program cost. When the cost exceeds a threshold, the program is terminated, and no value is returned."),Object(b.b)("h2",{id:"argument-checking-behaviour-with-fewer-or-more-args-than-required"},"Argument Checking: Behaviour with fewer or more args than required"),Object(b.b)("p",null,"Some opcodes have strict argument requirements, and others will work with more arguments than required, ignoring additional arguments (eg. listp). Opcodes taking an unlimited number of arguments have not been checked in the table below."),Object(b.b)("h3",{id:"opcode-list"},"Opcode List"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"keyword"),Object(b.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"opcode"),Object(b.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"implementation"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"q"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x01"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"NO IMPL")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"a"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x03"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"NO IMPL")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"i"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x04"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_if")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"c"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x05"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_cons")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"f"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x06"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_first")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"r"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x07"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_rest")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"l"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x08"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_listp")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"x"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x09"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_raise")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(b.b)("inlineCode",{parentName:"td"},"=")),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x0a"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_eq")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"sha256"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x0b"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_sha256")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(b.b)("inlineCode",{parentName:"td"},"+")),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x0c"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_add")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(b.b)("inlineCode",{parentName:"td"},"-")),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x0d"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_subtract")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(b.b)("inlineCode",{parentName:"td"},"*")),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x0e"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_multiply")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"divmod"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x0f"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_divmod")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"substr"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x10"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_substr")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"strlen"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x11"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_strlen")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"point_add"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x12"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_point_add")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"pubkey_for_exp"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x13"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_pubkey_for_exp")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"concat"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x14"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_concat")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"sha256tree"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x15"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_sha256tree")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(b.b)("inlineCode",{parentName:"td"},">")),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x16"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_gr")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(b.b)("inlineCode",{parentName:"td"},">s")),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x17"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_gr_bytes")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"logand"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x18"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_logand")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"logior"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x19"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_logior")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"logxor"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x1a"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_logxor")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"lognot"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x1b"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_lognot")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"ash"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x1c"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_ash")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"lsh"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x1d"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_lsh")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"softfork"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0x1e"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"op_softfork")))),Object(b.b)("h3",{id:"operator-results-when-called-with-zero-arguments"},"Operator Results when called with zero arguments"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"operator"),Object(b.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"value"),Object(b.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"brun return code"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"i"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: rest of non-cons ()"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"c"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: first of non-cons ()"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"f"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: first of non-cons ()"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"r"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: first of non-cons ()"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"l"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: first of non-cons ()"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"x"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: clvm raise ()"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"="),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: first of non-cons ()"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"sha256"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(b.b)("inlineCode",{parentName:"td"},"+")),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"()"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(b.b)("inlineCode",{parentName:"td"},"-")),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"cannot unpack non-iterable SExp object"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"1")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(b.b)("inlineCode",{parentName:"td"},"*")),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"1"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"divmod"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: divmod requires 2 args ()"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"substr"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: first of non-cons ()"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"strlen"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: first of non-cons ()"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"point_add"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0xc00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"pubkey_for_exp"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: pubkey_for_exp requires 1 arg ()"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"concat"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"()"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"sha256tree"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: op_sha256tree expects exactly one argument ()"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(b.b)("inlineCode",{parentName:"td"},">")),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: > requires 2 args ()"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(b.b)("inlineCode",{parentName:"td"},">s")),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: >s requires 2 args ()"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"logand"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"-1"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"logior"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"()"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"logxor"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"()"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"lognot"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: lognot requires 1 arg ()"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"ash"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: ash requires 2 args ()"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"lsh"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: ash requires 2 args ()"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"softfork"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: first of non-cons ()"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")))),Object(b.b)("h3",{id:"operator-results-when-called-with-fewer-than-minimum-arguments"},"Operator Results when called with fewer than minimum arguments"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"program"),Object(b.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"value"),Object(b.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"brun return code"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),'(i  (q "A")  (q "A") )'),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"65"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),'(c  (q "A") )'),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: first of non-cons ()"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(f )"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: first of non-cons ()"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(r )"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: first of non-cons ()"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(l )"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: first of non-cons ()"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(x )"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: clvm raise ()"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),'(=  (q "A") )'),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: first of non-cons ()"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(sha256 )"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(+ )"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"()"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(- )"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"cannot unpack non-iterable SExp object"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"1")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(* )"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"1"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),'(divmod  (q "A") )'),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: divmod requires 2 args (65)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),'(substr  (q "A")  (q "A") )'),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: substr requires 2 args (65)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(strlen )"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: first of non-cons ()"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(point_add )"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0xc00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(pubkey_for_exp )"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: pubkey_for_exp requires 1 arg ()"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(concat )"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"()"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(sha256tree )"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: op_sha256tree expects exactly one argument ()"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),'(>  (q "A") )'),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: > requires 2 args (65)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),'(>s  (q "A") )'),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: >s requires 2 args (65)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(logand )"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"-1"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(logior )"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"()"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(logxor )"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"()"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(lognot )"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: lognot requires 1 arg ()"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),'(ash  (q "A") )'),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: ash requires 2 args (65)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),'(lsh  (q "A") )'),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: ash requires 2 args (65)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(softfork )"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: first of non-cons ()"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")))),Object(b.b)("h3",{id:"operator-results-when-called-with-too-many-arguments"},"Operator Results when called with too many arguments"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"operator"),Object(b.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"value"),Object(b.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"brun return code"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),'(i  (q "A")  (q "A")  (q "A")  (q "A") )'),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"65"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),'(c  (q "A")  (q "A")  (q "A") )'),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(65 . 65)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),'(f  (q "A")  (q "A") )'),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: first of non-cons 65"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),'(r  (q "A")  (q "A") )'),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: rest of non-cons 65"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),'(l  (q "A")  (q "A") )'),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"()"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"none"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Untested."),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"none")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),'(=  (q "A")  (q "A")  (q "A") )'),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"1"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"none"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Untested."),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"none")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"none"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Untested."),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"none")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"none"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Untested."),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"none")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"none"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Untested."),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"none")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),'(divmod  (q "A")  (q "A")  (q "A") )'),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: divmod requires 2 args (65 65 65)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),'(substr  (q "A")  (q "A")  (q "A")  (q "A") )'),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: substr requires 2 args (65 65 65)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),'(strlen  (q "A")  (q "A") )'),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"1"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"none"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Untested."),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"none")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),'(pubkey_for_exp  (q "A")  (q "A") )'),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: pubkey_for_exp requires 1 arg (65 65)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"none"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Untested."),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"none")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),'(sha256tree  (q "A")  (q "A") )'),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: op_sha256tree expects exactly one argument (65 65)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),'(>  (q "A")  (q "A")  (q "A") )'),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: > requires 2 args (65 65 65)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),'(>s  (q "A")  (q "A")  (q "A") )'),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: >s requires 2 args (65 65 65)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"none"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Untested."),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"none")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"none"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Untested."),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"none")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"none"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Untested."),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"none")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),'(lognot  (q "A")  (q "A") )'),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: lognot requires 1 arg (65 65)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),'(ash  (q "A")  (q "A")  (q "A") )'),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: ash requires 2 args (65 65 65)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),'(lsh  (q "A")  (q "A")  (q "A") )'),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FAIL: ash requires 2 args (65 65 65)"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"255")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),'(softfork  (q "A")  (q "A") )'),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"()"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"0")))),Object(b.b)("h3",{id:"conditions"},"Conditions"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Condition"),Object(b.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"CLVM Opcode"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"AGG_SIG"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"50")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"CREATE_COIN"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"51")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"ASSERT_COIN_CONSUMED"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"52")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"ASSERT_MY_COIN_ID"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"53")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"ASSERT_TIME_EXCEEDS"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"54")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"ASSERT_BLOCK_INDEX_EXCEEDS"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"55")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"ASSERT_BLOCK_AGE_EXCEEDS"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"56")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"AGG_SIG_ME"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"57")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"ASSERT_FEE"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"58")))))}O.isMDXComponent=!0},76:function(e,t,a){"use strict";a.d(t,"a",(function(){return j})),a.d(t,"b",(function(){return m}));var n=a(0),r=a.n(n);function b(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function c(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){b(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},b=Object.keys(e);for(n=0;n<b.length;n++)a=b[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var b=Object.getOwnPropertySymbols(e);for(n=0;n<b.length;n++)a=b[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var o=r.a.createContext({}),O=function(e){var t=r.a.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):c(c({},t),e)),a},j=function(e){var t=O(e.components);return r.a.createElement(o.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},d=r.a.forwardRef((function(e,t){var a=e.components,n=e.mdxType,b=e.originalType,l=e.parentName,o=i(e,["components","mdxType","originalType","parentName"]),j=O(a),d=n,m=j["".concat(l,".").concat(d)]||j[d]||p[d]||b;return a?r.a.createElement(m,c(c({ref:t},o),{},{components:a})):r.a.createElement(m,c({ref:t},o))}));function m(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var b=a.length,l=new Array(b);l[0]=d;var c={};for(var i in t)hasOwnProperty.call(t,i)&&(c[i]=t[i]);c.originalType=e,c.mdxType="string"==typeof e?e:n,l[1]=c;for(var o=2;o<b;o++)l[o]=a[o];return r.a.createElement.apply(null,l)}return r.a.createElement.apply(null,a)}d.displayName="MDXCreateElement"}}]);