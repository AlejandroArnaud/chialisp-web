(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{70:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return c})),a.d(t,"metadata",(function(){return i})),a.d(t,"rightToc",(function(){return l})),a.d(t,"default",(function(){return b}));var n=a(2),r=a(6),o=(a(0),a(92)),c={id:"doc3",title:"Part 3 - Deeper into CLVM"},i={unversionedId:"doc3",id:"doc3",isDocsHomePage:!1,title:"Part 3 - Deeper into CLVM",description:"This guide directly continues on from part 1 so if you haven't read that, please do so before reading this.",source:"@site/docs/doc3.md",permalink:"/docs/doc3",editUrl:"https://github.com/Chia-Network/chialisp-web/edit/master/docs/doc3.md",sidebar:"someSidebar",previous:{title:"Part 2 - Coins, Spends and Wallets",permalink:"/docs/doc2"},next:{title:"Part 4 - The Compiler and Other Useful Information",permalink:"/docs/doc4"}},l=[{value:"Lazy Evaluation in ChiaLisp",id:"lazy-evaluation-in-chialisp",children:[]},{value:"Introduction to Eval",id:"introduction-to-eval",children:[]},{value:"Programs as Parameters",id:"programs-as-parameters",children:[]},{value:"Example: Factorial",id:"example-factorial",children:[]},{value:"Recursion in Puzzles",id:"recursion-in-puzzles",children:[]}],s={rightToc:l};function b(e){var t=e.components,a=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(n.a)({},s,a,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"This guide directly continues on from ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"/docs/"}),"part 1")," so if you haven't read that, please do so before reading this."),Object(o.b)("p",null,"This section of the guide will cover how ChiaLisp relates to transactions and coins on the Chia network.\nIf there are any terms that you aren't sure of, be sure to check the ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"/docs/doc5"}),"glossary"),"."),Object(o.b)("h2",{id:"lazy-evaluation-in-chialisp"},"Lazy Evaluation in ChiaLisp"),Object(o.b)("p",null,"As we saw in part 1, programs are often structured around ",Object(o.b)("inlineCode",{parentName:"p"},"(i A B C)")," to control flow.\nChiaLisp evaluates programs as trees, where the leaves are evaluated first.\nThis can cause unexpected problems if you are not aware of it.\nConsider the following program which uses ",Object(o.b)("inlineCode",{parentName:"p"},"x")," which immediately halts and throws an error if it is evaluated."),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{}),"$ brun '(i (q 1) (q 100) (x (q \"still being evaluated\")))'\nFAIL: clvm raise (0x7374696c6c206265696e67206576616c7561746564)\n")),Object(o.b)("p",null,"This is because ChiaLisp evaluates both of the leaves even though it will only follow the path of one."),Object(o.b)("p",null,"To get around this we can use the following design pattern to replace (i A B C)."),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{}),"((c (i (A) (q B) (q C)) (a)))\n")),Object(o.b)("p",null,"Applying this to our above example looks like this:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{}),"$ brun '((c (i (q 1) (q (q 100)) (q (x (q \"still being evaluated\")))) (a)))'\n100\n")),Object(o.b)("p",null,"It is worth keeping this in mind whenever you write an ",Object(o.b)("inlineCode",{parentName:"p"},"(i A B C)"),"."),Object(o.b)("p",null,"If you're wondering how this works (and how the standard transaction from ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"/docs/doc2"}),"part 2")," worked), then allow me to introduce Eval."),Object(o.b)("h2",{id:"introduction-to-eval"},"Introduction to Eval"),Object(o.b)("p",null,"In ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"/docs/"}),"Part 1")," we mentioned that a program is usually a list where the first element is an operator, and every subsequent element is a valid program.\nHowever a Program can also have a program as the first element. This will cause that program to be evaluated as a new puzzle.\nThe solution is then every element after the first in this list."),Object(o.b)("p",null,"This looks like this:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{}),"((*puzzle*) *solution* *elements* *go* *here*)\n")),Object(o.b)("p",null,"In order to create this list we want to use:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{}),"((c (*puzzle*) (*solution*)))\n")),Object(o.b)("p",null,"Let's put this into practice."),Object(o.b)("p",null,"Here is a program that evaluates the program ",Object(o.b)("inlineCode",{parentName:"p"},"(+ (f (a) (q 5)))")," and uses the list ",Object(o.b)("inlineCode",{parentName:"p"},"(70 80 90)")," or ",Object(o.b)("inlineCode",{parentName:"p"},"(80 90 100)")," as the solution."),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{}),"$ brun '((c (q (+ (f (a)) (q 5))) (q (70 80 90))))' '(20 30 40)'\n75\n\n$ brun '((c (q (+ (f (a)) (q 5))) (q (80 90 100))))' '(20 30 40)'\n85\n\n")),Object(o.b)("p",null,"Notice how the original solution ",Object(o.b)("inlineCode",{parentName:"p"},"(20 30 40)")," does not matter for the new evaluation environment.\nIn this example we use ",Object(o.b)("inlineCode",{parentName:"p"},"q")," to quote both the new puzzle and the new solution to prevent them from being prematurely evaluated."),Object(o.b)("p",null,"A neat trick that we can pull is that we can define the new solution in terms of the outer solution.\nIn this next example we will add the first element of the old solution to our new solution."),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{}),"$ brun '((c (q (+ (f (a)) (q 5))) (c (f (a)) (q (70 80 90)))))' '(20 30 40)'\n25\n")),Object(o.b)("p",null,"However it's not just the new solution that we can affect using this, we can also pass programs as parameters."),Object(o.b)("h2",{id:"programs-as-parameters"},"Programs as Parameters"),Object(o.b)("p",null,"The core CLVM does not have an operator for creating user defined functions.\nIt does, however, allow programs to be passed as parameters, which can be used for similar results."),Object(o.b)("p",null,"Here is a puzzle that executes the program contained in ",Object(o.b)("inlineCode",{parentName:"p"},"(f (a))")," with the solution ",Object(o.b)("inlineCode",{parentName:"p"},"(12)"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{}),"$ brun '((c (f (a)) (q (12))))' '((* (f (a)) (q 2)))'\n24\n")),Object(o.b)("p",null,"Taking this further we can make the puzzle run a new evaluation that only uses parameters from its old solution:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{}),"$ brun '((c (f (a)) (a)))' '((* (f (r (a)) (q 2))) 10)'\n10\n")),Object(o.b)("p",null,"We can use this technique to implement recursive programs."),Object(o.b)("h2",{id:"example-factorial"},"Example: Factorial"),Object(o.b)("p",null,"Consider the recursive function for a factorial, which is written in pseudo-code below:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{}),"(i (= (f (a)) (q 1)) (q 1) (* (f (a)) (factorial (- (f (a)) (q 1)))))\n")),Object(o.b)("p",null,"Overlooking the fact that ",Object(o.b)("inlineCode",{parentName:"p"},"factorial")," is not an operator, this code contains one other problem. Can you spot it?"),Object(o.b)("p",null,"It's not using lazy evaluation.\n",Object(o.b)("strong",{parentName:"p"},"If you don't force lazy evaluation, your recursive programs will try to evaluate infinitely and crash.")),Object(o.b)("p",null,"Here is the fixed pseudo-code using the ",Object(o.b)("inlineCode",{parentName:"p"},"((c (i (A) (q B) (q C)) (a)))")," pattern:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{}),"((c (i (= (f (a)) (q 1)) (q (q 1)) (q (* (f (a)) (factorial (- (f (a)) (q 1)))))) (a)))\n")),Object(o.b)("p",null,"The next step is to replace ",Object(o.b)("inlineCode",{parentName:"p"},"factorial"),"."),Object(o.b)("p",null,"While we can't define a new operator, we can encode the factorial function as a parameter and evaluate it as a puzzle.\nLet's create a solution where ",Object(o.b)("inlineCode",{parentName:"p"},"(f (a))")," is our factorial code, and ",Object(o.b)("inlineCode",{parentName:"p"},"(f (r (a)))")," is the number we are operating on."),Object(o.b)("p",null,"When calling the factorial program we want to create a new solution where ",Object(o.b)("inlineCode",{parentName:"p"},"(f (r (a)))")," is decremented by 1."),Object(o.b)("p",null,"It is a good idea when creating ChiaLisp programs to break it down to sub programs, so let's create and test our new solution generating program:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{}),"$ brun '(c (f (a)) (c (- (f (r (a))) (q 1)) (q ())))' '(\"source code\" 100)'\n(\"source code\" 99)\n")),Object(o.b)("p",null,"Perfect."),Object(o.b)("p",null,"We can now use this smaller fragment to construct our finished factorial source code:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{}),"(((c (i (= (f (r (a))) (q 1)) (q (q 1)) (q (* (f (r (a))) ((c (f (a)) (c (f (a)) (c (- (f (r (a))) (q 1)) (q ())))))))) (a))) *num to factorial*)\n")),Object(o.b)("p",null,"and we can call it using the puzzle ",Object(o.b)("inlineCode",{parentName:"p"},"((c (f (a)) (a)))")),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{}),"$ brun '((c (f (a)) (a)))' '(((c (i (= (f (r (a))) (q 1)) (q (q 1)) (q (* (f (r (a))) ((c (f (a)) (c (f (a)) (c (- (f (r (a))) (q 1)) (q ())))))))) (a))) 5)'\n120\n\n$ brun '((c (f (a)) (a)))' '(((c (i (= (f (r (a))) (q 1)) (q (q 1)) (q (* (f (r (a))) ((c (f (a)) (c (f (a)) (c (- (f (r (a))) (q 1)) (q ())))))))) (a))) 6)'\n720\n")),Object(o.b)("p",null,"It works!"),Object(o.b)("p",null,"But there is one final step. We need to encode this as part of the puzzle.\nThe above example assumes we have control of the solution.\nBut in the context of ChiaLisp the puzzle is securing our money, and we must be prepared for malicious solutions."),Object(o.b)("h2",{id:"recursion-in-puzzles"},"Recursion in Puzzles"),Object(o.b)("p",null,"We need to create a new eval environment where the program code is passed in - then call that code again as a parameter.\nHere we need to"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{}),"((c (q ((c (f (a)) (a)))) (c (q (*program*)) (c (f (a)) (q ())))))\n")),Object(o.b)("p",null,"Notice that we need to run eval ",Object(o.b)("inlineCode",{parentName:"p"},"((c () ()))")," twice.\nOnce to create an environment where the source code exists and once again to run that source code.\nIf you compare that pattern with the way we constructed the factorial above, you should see the similarity."),Object(o.b)("p",null,"So let's replace ",Object(o.b)("inlineCode",{parentName:"p"},"*program*")," with our factorial program from above."),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{}),"((c (q ((c (f (a)) (a)))) (c (q ((c (i (= (f (r (a))) (q 1)) (q (q 1)) (q (* (f (r (a))) ((c (f (a)) (c (f (a)) (c (- (f (r (a))) (q 1)) (q ())))))))) (a)))) (c (f (a)) (q ())))))\n")),Object(o.b)("p",null,"And let's test it with clvm_tools"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{}),"$ brun '((c (q ((c (f (a)) (a)))) (c (q ((c (i (= (f (r (a))) (q 1)) (q (q 1)) (q (* (f (r (a))) ((c (f (a)) (c (f (a)) (c (- (f (r (a))) (q 1)) (q ())))))))) (a)))) (c (f (a)) (q ())))))' '(5)'\n120\n")),Object(o.b)("p",null,"We now have a design pattern that allows us to create recursive programs that can be part of smart contracts, and more complicated ChiaLisp puzzles."))}b.isMDXComponent=!0}}]);