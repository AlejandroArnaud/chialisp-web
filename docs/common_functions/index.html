<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.72">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Chialisp Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Chialisp Blog Atom Feed"><title data-react-helmet="true">5 - Common Functions in Chialisp | Chialisp</title><meta data-react-helmet="true" property="og:url" content="https://chialisp.com/docs/common_functions"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="5 - Common Functions in Chialisp | Chialisp"><meta data-react-helmet="true" name="description" content="When you start to write full smart contracts, you will start to realize that you will need certain common functionality in a lot of puzzles.  Let&#x27;s go over how to include them and what some of them are:"><meta data-react-helmet="true" property="og:description" content="When you start to write full smart contracts, you will start to realize that you will need certain common functionality in a lot of puzzles.  Let&#x27;s go over how to include them and what some of them are:"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://chialisp.com/docs/common_functions"><link data-react-helmet="true" rel="alternate" href="https://chialisp.com/docs/common_functions" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://chialisp.com/docs/common_functions" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.524535a3.css">
<link rel="preload" href="/assets/js/styles.26f56164.js" as="script">
<link rel="preload" href="/assets/js/runtime~main.ff70132a.js" as="script">
<link rel="preload" href="/assets/js/main.fee5b939.js" as="script">
<link rel="preload" href="/assets/js/1.770ac2bf.js" as="script">
<link rel="preload" href="/assets/js/2.51d5087f.js" as="script">
<link rel="preload" href="/assets/js/3.377891e5.js" as="script">
<link rel="preload" href="/assets/js/1be78505.d5247ac1.js" as="script">
<link rel="preload" href="/assets/js/24.7aadb6e8.js" as="script">
<link rel="preload" href="/assets/js/935f2afb.02b7fb0a.js" as="script">
<link rel="preload" href="/assets/js/17896441.1001ec9f.js" as="script">
<link rel="preload" href="/assets/js/e4b313ae.72f3feff.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="Chialisp Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.svg" alt="Chialisp Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><strong class="navbar__title">Chialisp</strong></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/">Docs</a><a href="https://chia.net/blog" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog</a><a href="https://chia.net" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Chia.net</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/Chia-Network/chialisp-web" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_GrZ2"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">ðŸŒœ</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">ðŸŒž</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="Chialisp Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.svg" alt="Chialisp Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><strong class="navbar__title">Chialisp</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/docs/">Docs</a></li><li class="menu__list-item"><a href="https://chia.net/blog" target="_blank" rel="noopener noreferrer" class="menu__link">Blog</a></li><li class="menu__list-item"><a href="https://chia.net" target="_blank" rel="noopener noreferrer" class="menu__link">Chia.net</a></li><li class="menu__list-item"><a href="https://github.com/Chia-Network/chialisp-web" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper main-docs-wrapper"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo"><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">Chialisp</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/">1 - CLVM Basics</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/coins_spends_and_wallets">2 - Coins, Spends and Wallets</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/deeper_into_clvm">3 - Deeper into CLVM</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/high_level_lang">4 - The High Level Language, Compiler, and Functions</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/docs/common_functions">5 - Common Functions in Chialisp</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/glossary">The Great Chia Glossary</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">CLVM</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/ref/clvm">1 - The CLVM</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/ref/serialization">2 - Serialization</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">FAQ</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/faq">ChiaLisp and CLVM FAQ</a></li></ul></li></ul></div></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">5 - Common Functions in Chialisp</h1></header><div class="markdown"><p>When you start to write full smart contracts, you will start to realize that you will need certain common functionality in a lot of puzzles.  Let&#x27;s go over how to include them and what some of them are:</p><h2 id="include">include</h2><p>If you want to import some functionality that you use frequently without having to copy/paste it between files, you can use <code>include</code>:</p><pre><code class="language-lisp">;; condition_codes.clvm
(
  (defconstant AGG_SIG_ME 50)
  (defconstant CREATE_COIN 51)
)
</code></pre><pre><code class="language-lisp">;;main.clvm
(mod create_sig_coin (pubkey msg puzzle_hash amount)

  (include &quot;condition_codes.clvm&quot;)

  (list (list AGG_SIG_ME pubkey msg) (list CREATE_COIN puzzle_hash amount))

)
</code></pre><p>When running main.clvm with <code>run</code>, make sure to use the <code>-i</code> option to specify in which directories to look for files.</p><p>Also note that the include files are a special format. Everything that is defined goes into a single set of parentheses like in condition_codes.clvm above.  You can then use any of those constants/functions when writing your program, without having to import each one individually.  The compiler will only include things that you use, so don&#x27;t worry about including a large library file when attempting to optimize the size of your program.</p><h2 id="sha256tree1">sha256tree1</h2><p>When puzzles are hashed, they are not simply serialized and passed to sha256.  Instead, we take the <em>tree hash</em> of the puzzle.</p><p>Recall that every clvm program can be represented as a binary tree.  Every object is either an atom (a leaf of the tree) or a cons box (a branch of the tree).  When we hash the puzzle we start at the leaves of the tree and hash our way up, concatenating either a 1 or a 2 to denote that it&#x27;s either an atom or a cons box.  Once a cons box is hashed, it becomes a new leaf to be hashed into its parent cons box and the process recurses.  Here&#x27;s what that looks like in Chialisp:</p><pre><code class="language-lisp">(defun sha256tree1
   (TREE)
   (if (l TREE)
       (sha256 2 (sha256tree1 (f TREE)) (sha256tree1 (r TREE)))
       (sha256 1 TREE)
   )
)
</code></pre><p>It is extremely useful to calculate tree hashes within a Chialisp puzzle.  You can assert puzzles of other coins, condense puzzles for easier signing, and make CREATE_COIN conditions that are dependent on some passed in data.  </p><h2 id="currying">Currying</h2><p>Currying is an extremely important concept in Chialisp that is responsible for almost the entirety of how state is stored in coins.  The idea is to pass in arguments to a puzzle <em>before</em> it is hashed.  When you curry, you commit to solution values so that the individual solving the puzzle cannot change them.  Let&#x27;s take a look at how this is implemented in Chialisp:</p><pre><code class="language-lisp">;; utility function used by curry
(defun fix_curry_args (items core)
 (if items
     (qq (c (q . (unquote (f items))) (unquote (fix_curry_args (r items) core))))
     core
 )
)

; (curry sum (list 50 60)) =&gt; returns a function that is like (sum 50 60 ...)
(defun curry (func list_of_args) (qq (a (q . (unquote func)) (unquote (fix_curry_args list_of_args (q . 1))))))
</code></pre><p>The reason this is so useful is because you may want to create the blueprint of a puzzle, but use different values for certain parameters every time you create it.  You can&#x27;t rely on the puzzle solver to honestly and correctly pass in the information you want to use, so you need to make sure it is passed in before they ever get the chance to solve it.</p><p>The above function may look complex, but all it&#x27;s really doing is wrapping the function in an <code>a</code> and prepending the arguments to <code>1</code> which (when compiled to clvm) will refer the rest of the puzzle arguments.  Absent of all the quotes, the above code reduces to something like this:</p><pre><code class="language-lisp">(a func (c curry_arg_1 (c curry_arg_2 1)))
</code></pre><p>You can also do the reverse operation.  Given a program, you can <em>uncurry</em> the list of arguments, with a simple <code>(f (r (r )))</code>:</p><pre><code class="language-lisp">(f (r (r curried_func)))
; (c curry_arg_1 (c curry_arg_2 1))
</code></pre><p>Let&#x27;s take our password locked coin example from earlier, this time as a Chialisp puzzle:</p><pre><code class="language-lisp">(mod (password new_puzhash amount)
  (defconstant CREATE_COIN 51)

  (defun check_password (password new_puzhash amount)

    (if (= (sha256 password) (q . 0x2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824))
      (list (list CREATE_COIN new_puzhash amount))
      (x)
    )
  )

  ; main
  (check_password password new_puzhash amount)
)
</code></pre><p>You can see that the password hash is baked into the source of the puzzle.  This means every time that you want to lock up a coin with a new password, you have to recreate the file that contains the source of the code.  It would be much nicer if we fully generalized it:</p><pre><code class="language-lisp">(mod (PASSWORD_HASH password new_puzhash amount)
  (defconstant CREATE_COIN 51)

  (defun check_password (PASSWORD_HASH password new_puzhash amount)

    (if (= (sha256 password) PASSWORD_HASH)
      (list (list CREATE_COIN new_puzhash amount))
      (x)
    )
  )

  ; main
  (check_password PASSWORD_HASH password new_puzhash amount)
)
</code></pre><p>However, now we have the problem that anyone can pass in whatever password/hash combo that they please and unlock this coin.  When we create this coin we need the password hash to be committed to. Before determining the puzzle hash of the coin we&#x27;re going to create, we need to curry in the hash with something like this:</p><pre><code class="language-lisp">; curry_password_coin.clvm
(mod (password_hash password_coin_mod)
  (include &quot;curry.clvm&quot;) ; From above

  (curry password_coin_mod (list password_hash))
)
</code></pre><p>If we compile this function and pass it parameters like this:</p><pre><code>brun &lt;curry password coin mod&gt; &#x27;((q . 0xcafef00d) (q . &lt;password coin mod&gt;))&#x27;
</code></pre><p>we will receive a puzzle that looks very similar to our password coin module, but has been expanded to include the hash we passed in.  You can now run the currying mod above with a different password hash and it will output a new puzzle every time.  We can then hash that puzzle and create a coin with the returned puzzle hash.</p><p>Note that this required that we run the currying module using <code>brun</code> in our own environment off chain in order to create the puzzle we would lock up our coin with.  A lot of the time this currying will happen in python or whatever wrapper language is being used by the software creating the coins.  However, there are some use cases in which we would want to use currying within the scope of a puzzle.  Let&#x27;s look at one now.</p><h2 id="outer-and-inner-puzzles">Outer and Inner puzzles</h2><p>A common design pattern, and one of the most powerful features of Chialisp, is the ability to have an outer smart contract the &quot;wraps&quot; an inner puzzle.  This concept is extremely handy because it allows a coin to retain all of it&#x27;s standard functionality and programmability within the inner puzzle, but be bound to an extra set of rules by the outer puzzle.</p><p>For this example, we&#x27;re going to continue with our password locking, but this time we&#x27;re going to require that every time the coin is spent, it requires a new password to be set.  Let&#x27;s look at all the code and then we&#x27;ll break it down:</p><pre><code class="language-lisp">(mod (
    MOD_HASH        ;; curried in
    PASSWORD_HASH   ;; curried in
    INNER_PUZZLE    ;; curried in
    inner_solution
    password
    new_password_hash
  )

  (include &quot;condition_codes.clvm&quot;)
  (include &quot;sha256tree1.clvm&quot;)
  (include &quot;curry-and-treehash.clvm&quot;)

  (defun pw-puzzle-hash (MOD_HASH mod_hash_hash new_password_hash_hash inner_puzzle_hash)
     (puzzle-hash-of-curried-function
       MOD_HASH
       inner_puzzle_hash new_password_hash_hash mod_hash_hash ; parameters must be passed in reverse order
     )
   )

  ;; tweak `CREATE_COIN` condition by wrapping the puzzle hash, forcing it to be a password locked coin
  (defun-inline morph-condition (condition new_password_hash MOD_HASH)
   (if (= (f condition) CREATE_COIN)
     (list CREATE_COIN
       (pw-puzzle-hash MOD_HASH (sha256tree1 MOD_HASH) (sha256tree1 new_password_hash) (f (r condition)))
       (f (r (r condition)))
     )
     condition
   )
  )

  ;; tweak all `CREATE_COIN` conditions, enforcing created coins to be locked by passwords
  (defun morph-conditions (conditions new_password_hash MOD_HASH)
   (if conditions
     (c
       (morph-condition (f conditions) new_password_hash MOD_HASH)
       (morph-conditions (r conditions) new_password_hash MOD_HASH)
     )
     ()
   )
  )

  ; main
  (if (= (sha256 password) PASSWORD_HASH)
    (morph-conditions (a INNER_PUZZLE inner_solution) new_password_hash MOD_HASH)
    (x &quot;wrong password&quot;)
  )

)
</code></pre><p>You may notice that we imported a new library called <code>curry-and-treehash</code>.  We&#x27;ll talk about that in a few steps.</p><p>First, let&#x27;s talk about the arguments.  When you create this puzzle for the first time you need to curry in 3 things: <code>MOD_HASH</code> which is the tree hash of this code, <code>PASSWORD_HASH</code> which is the hash of the password that will unlock this coin, and <code>INNER_PUZZLE</code> which is a completely separate puzzle that will have its own rules about how the coin can be spent.</p><p>Chialisp puzzles have the tendency to be read from the bottom up, so lets start with this chunk:</p><pre><code class="language-lisp">; main
(if (= (sha256 password) PASSWORD_HASH)
  (morph-conditions (a INNER_PUZZLE inner_solution) new_password_hash MOD_HASH)
  (x &quot;wrong password&quot;)
)
</code></pre><p>All that&#x27;s happening here is that we&#x27;re making sure the password is correct and, if it is, we&#x27;re going to run the curried in <code>INNER_PUZZLE</code> with the passed in <code>inner_solution</code>.  This will return a list of opcodes that we will pass to the next function along with the new password hash and <code>MOD_HASH</code>.</p><pre><code class="language-lisp">;; tweak all `CREATE_COIN` conditions, enforcing created coins to be locked by passwords
(defun morph-conditions (conditions new_password_hash MOD_HASH)
 (if conditions
   (c
     (morph-condition (f conditions) new_password_hash MOD_HASH)
     (morph-conditions (r conditions) new_password_hash MOD_HASH)
   )
   ()
 )
)
</code></pre><p>Recursion is the foundation of Chialisp and functions like these very commonly show up when writing it.  In order to iterate through the list of conditions, we first check if there are still items left (remember that an empty list <code>()</code> or <strong>nil</strong> evaluates to false). Then, we morph the first condition and concatenate it with the recursive output of the rest of the list.  In the end, we will have the same list of items in the same order, but all of them will have passed thru <code>morph-condition</code>.</p><pre><code class="language-lisp">;; tweak `CREATE_COIN` condition by wrapping the puzzle hash, forcing it to be a password locked coin
(defun-inline morph-condition (condition new_password_hash MOD_HASH)
 (if (= (f condition) CREATE_COIN)
   (list CREATE_COIN
     (pw-puzzle-hash MOD_HASH (sha256tree1 MOD_HASH) (sha256tree1 new_password_hash) (f (r condition)))
     (f (r (r condition)))
   )
   condition
 )
)
</code></pre><p>This function is also pretty simple. We&#x27;re first checking if the opcode (first item in the list) is CREATE_COIN.  If it&#x27;s not, just return the condition as usual.  If it is, return a condition that is almost exactly the same, except we&#x27;re passing the puzzle hash into a function that will modify it:</p><pre><code class="language-lisp">(defun pw-puzzle-hash (MOD_HASH mod_hash_hash new_password_hash_hash inner_puzzle_hasr
   (puzzle-hash-of-curried-function
     MOD_HASH
     inner_puzzle_hash new_password_hash_hash mod_hash_hash ; parameters must be passed in reverse order
   )
)
</code></pre><p>This is where the exciting stuff happens.  Since we don&#x27;t know the inner puzzle, only it&#x27;s hash, it&#x27;s impossible to curry it directly into the next puzzle we want to create.  Furthermore, if we don&#x27;t want to pass in the whole source of this current module every time that we spend it, we don&#x27;t have a puzzle to curry things into either.</p><p>However, all we care about is generating the correct <em>puzzle hash</em> for the next puzzle, and we do have the tree hashes for both this module and the inner puzzle.  We can use <code>puzzle-hash-of-curried-function</code> which allows us to create the puzzle hash of a function given: a) the puzzle hash of that function and b) the puzzle hashes of all of its arguments in reverse order.  The implementation details of this library are a bit much to go into in this part of the tutorial but, in essence, it allows us to <em>resume</em> a tree hash that we have completed except for the last step.</p><p>And that&#x27;s it!  When this coin is created, it can only be spent by a password that hashes to the curried in PASSWORD_HASH.  The inner puzzle can be anything that you want including other smart contracts that have their own inner puzzles.  Whatever coins get created as a result of that inner puzzle will be &quot;wrapped&quot; by this same outer puzzle ensuring that every child of this coin is locked by a password <em>forever</em>.</p><p>We created a simple coin, but you can see the potential of this. You can enforce a set of rules not only on a coin that you lock up, but on <em>every</em> descendant coin.  Not only that, the rules can be enforced <em>on top of other smart contracts</em>.  In the Chialisp ecosystem, all smart contracts are interoperable with each other unless otherwise specified by a parent smart contract. The possibilities are endless and represent the vast programmability that Chialisp enables for coins.</p><p>In the next section, we&#x27;ll talk about how the network handles the coins and what you need to know before you try to deploy one yourself.</p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/Chia-Network/chialisp-web/edit/master/docs/common_functions.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/high_level_lang"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Â« 4 - The High Level Language, Compiler, and Functions</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/glossary"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">The Great Chia Glossary Â»</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#include" class="table-of-contents__link">include</a></li><li><a href="#sha256tree1" class="table-of-contents__link">sha256tree1</a></li><li><a href="#currying" class="table-of-contents__link">Currying</a></li><li><a href="#outer-and-inner-puzzles" class="table-of-contents__link">Outer and Inner puzzles</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Docs</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/">CLVM Basics</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/coins_spends_and_wallets/">Coins, Spends and Wallets</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Community</h4><ul class="footer__items"><li class="footer__item"><a href="https://keybase.io/team/chia_network.public" target="_blank" rel="noopener noreferrer" class="footer__link-item">Keybase</a></li><li class="footer__item"><a href="https://twitter.com/chia_project" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">More</h4><ul class="footer__items"><li class="footer__item"><a href="https://www.chia.net/blog/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Blog</a></li><li class="footer__item"><a href="https://github.com/Chia-Network/clvm" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub</a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright Â© 2021 Chia Network Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/styles.26f56164.js"></script>
<script src="/assets/js/runtime~main.ff70132a.js"></script>
<script src="/assets/js/main.fee5b939.js"></script>
<script src="/assets/js/1.770ac2bf.js"></script>
<script src="/assets/js/2.51d5087f.js"></script>
<script src="/assets/js/3.377891e5.js"></script>
<script src="/assets/js/1be78505.d5247ac1.js"></script>
<script src="/assets/js/24.7aadb6e8.js"></script>
<script src="/assets/js/935f2afb.02b7fb0a.js"></script>
<script src="/assets/js/17896441.1001ec9f.js"></script>
<script src="/assets/js/e4b313ae.72f3feff.js"></script>
</body>
</html>